#+LaTeX_HEADER: \usepackage{amsmath, amsfonts, listings, amsthm, mathtools, graphicx, tkz-graph, tikz, outlines, fixmath, marginnote, pdfpages, mathrsfs, mathtools, inputenc, todonotes, placeins, bm}
#+Title: blog 4
#+AUTHOR: Joseph Willard
#+LaTeX: \setcounter{secnumdepth}{0}
#+LaTeX: \newpage
#+STARTUP: hideblocks indent hidestars
#+OPTIONS: ^:nil toc:nil d:(not "logbook" "todo" "note" "notes") tex:t |:t broken-links:mark
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+PROPERTY: header-args :session tf :exports both :eval never-export :results output drawer replace
#+PROPERTY: header-args:text :eval never
#+OPTIONS: toc:nil

* Ideas :noexport:
** Look at Automatic Re-centering and Re-scaling
*** Convert to pymc4 using tensorflow
**** Look at https://colab.research.google.com/github/tensorflow/probability/blob/master/tensorflow_probability/examples/jupyter_notebooks/HLM_TFP_R_Stan.ipynb#scrollTo=QkchUh3V382r 
***** Section 6

* Porting theano ideas :noexport:
#+NAME:
#+BEGIN_SRC python -n :exports both :results output
  def optimize_graph(x, optimization, return_graph=None, in_place=False):
      """Easily optimize Theano graphs.

      Apply an optimization to either the graph formed by a Theano variable or an
      existing graph and return the resulting optimized graph.

      When given an existing `FunctionGraph`, the optimization is
      performed without side-effects (i.e. won't change the given graph).

      """
      if not isinstance(x, tt_FunctionGraph):
          inputs = tt_inputs([x])
          outputs = [x]
          model_memo = clone_get_equiv(inputs, outputs, copy_orphans=False)
          cloned_inputs = [model_memo[i] for i in inputs if not isinstance(i, tt.Constant)]
          cloned_outputs = [model_memo[i] for i in outputs]

          x_graph = FunctionGraph(cloned_inputs, cloned_outputs, clone=False)
          x_graph.memo = model_memo

          if return_graph is None:
              return_graph = False
      else:
          x_graph = x

          if return_graph is None:
              return_graph = True

      x_graph_opt = x_graph if in_place else x_graph.clone()
      _ = optimization.optimize(x_graph_opt)

      if return_graph:
          res = x_graph_opt
      else:
          res = x_graph_opt.outputs
          if len(res) == 1:
              res, = res
      return res


  def canonicalize(x, **kwargs):
      """Canonicalize a Theano variable and/or graph."""
      return optimize_graph(x, canonicalize_opt, **kwargs)

#+END_SRC

#+CAPTION:

* work :noexport:

#+BEGIN_SRC python -n :exports both :results output
  import numpy as np
  import pandas as pd

  import pymc4 as pm

  from pymc4.distributions import abstract

  from pymc4 import distributions as dist

  from pymc4.distributions.tensorflow.distribution import BackendDistribution

  from unification import var

  from kanren import run

  from symbolic_pymc.tensorflow.meta import mt

  from symbolic_pymc.relations.tensorflow import *

  import tensorflow_probability as tfp

  from tensorflow.python.framework.ops import disable_eager_execution

  disable_eager_execution()

  data = pd.read_csv('https://github.com/pymc-devs/pymc3/raw/master/pymc3/examples/data/radon.csv')
  county_names = data.county.unique()
  county_idx = data.county_code.values

  n_counties = len(data.county.unique())


  @pm.model(keep_return=False)
  def nested_model(a, b, eps, log_data):
      y = yield dist.Normal('radon_like', mu=a + b.sample() * data.floor.values,
                            sigma=eps,
                            observed=log_data)
      return y

  @pm.model
  def model_centered():
      mu_a = yield dist.Normal('mu_a', mu=0., sigma=100**2)
      sigma_a = yield dist.HalfNormal('sigma_a', mu=0., sigma=100**2)
      mu_b = yield dist.Normal('mu_b', mu=0., sigma=100**2)
      sigma_b = yield dist.HalfNormal('sigma_b', mu=0., sigma=100**2)
      a = yield dist.Normal('a', mu=mu_a, sigma=sigma_a, shape=n_counties)
      b = dist.Normal('b', mu=mu_b, sigma=sigma_b, shape=n_counties)
      eps = yield dist.HalfNormal('eps', mu=0., sigma=100**2)    
      radon_like = yield nested_model(a, b, eps, data.log_radon)
      return radon_like

  ret, state = pm.evaluate_model(model_centered())
#+END_SRC


