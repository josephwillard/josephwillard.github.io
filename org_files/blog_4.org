#+LaTeX_HEADER: \usepackage{amsmath, amsfonts, listings, amsthm, mathtools, graphicx, tkz-graph, tikz, outlines, fixmath, marginnote, pdfpages, mathrsfs, mathtools, inputenc, todonotes, placeins, bm}
#+Title: blog 4
#+AUTHOR: Joseph Willard
#+LaTeX: \setcounter{secnumdepth}{0}
#+LaTeX: \newpage
#+STARTUP: hideblocks indent hidestars
#+OPTIONS: ^:nil toc:nil d:(not "logbook" "todo" "note" "notes") tex:t |:t broken-links:mark
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport

#+PROPERTY: header-args :session tf :exports both :eval never-export :results output drawer replace
#+PROPERTY: header-args:text :eval never
#+OPTIONS: toc:nil

* Ideas :noexport:
** Look at Automatic Re-centering and Re-scaling
*** Convert to pymc4 using tensorflow
**** Look at https://colab.research.google.com/github/tensorflow/probability/blob/master/tensorflow_probability/examples/jupyter_notebooks/HLM_TFP_R_Stan.ipynb#scrollTo=QkchUh3V382r 
***** Section 6
* work :noexport:

#+BEGIN_SRC python -n :exports both :results output

  import numpy as np
  import pandas as pd

  import pymc4 as pm

  from pymc4.distributions import abstract

  from pymc4 import distributions as dist

  from pymc4.distributions.tensorflow.distribution import BackendDistribution

  from unification import var

  from kanren import run

  from symbolic_pymc.tensorflow.meta import mt

  from symbolic_pymc.relations.tensorflow import *

  import tensorflow_probability as tfp
  # from symbolic_pymc.relations.theano.distributions import scale_loc_transform


  # tt.config.compute_test_value = 'ignore'

  data = pd.read_csv('https://github.com/pymc-devs/pymc3/raw/master/pymc3/examples/data/radon.csv')
  county_names = data.county.unique()
  county_idx = data.county_code.values

  n_counties = len(data.county.unique())


  class HalfCauchy(BackendDistribution, abstract.Normal):
      __doc__ = r"""{}
      Developer Notes
      ---------------
      Parameter mappings to TensorFlow Probability are as follows:
      - mu: loc
      - sigma: scale
      """.format(
          "HalfCauchy"
      )

      def _init_backend(self):
          mu, sigma = self.conditions["mu"], self.conditions["sigma"]
          self._backend_distribution = tfp.distributions.half_cauchy(loc=mu, scale=sigma)




  @pm.model
  def model_centered():
      mu_a = yield dist.Normal('mu_a', mu=0., sigma=100**2)
      sigma_a = yield dist.HalfNormal('sigma_a', mu=0., sigma=100**2)
      mu_b = yield dist.Normal('mu_b', mu=0., sigma=100**2)
      sigma_b = yield dist.HalfNormal('sigma_b', mu=0., sigma=100**2)
      a = yield dist.Normal('a', mu=mu_a, sigma=sigma_a, shape=n_counties)
      b = yield dist.Normal('b', mu=mu_b, sigma=sigma_b, shape=n_counties)
      eps = yield dist.HalfNormal('eps', mu=0., sigma=100**2)
      radon_est = a[county_idx] + b[county_idx] * data.floor.values
      radon_like = yield dist.Normal('radon_like', mu=radon_est, sigma=eps,
                                     observed=data.log_radon)
      return radon_like
    


  # Convert the PyMC3 graph into a symbolic-pymc graph
  #fgraph = model_graph(model_centered)
  # Perform a set of standard algebraic simplifications
  fgraph = canonicalize(fgraph, in_place=False)


  def reparam_graph(graph):
      """Apply re-parameterization relations throughout a graph."""

      graph_mt = mt(graph)

      expr_graph = run(0, var('q'),
                       # Apply our transforms to unobserved RVs only
                       non_obs_graph_applyo(
                           lambda x, y: tt_graph_applyo(scale_loc_transform, x, y),
                           graph_mt, var('q')))

      expr_graph = expr_graph[0]
      opt_graph_tt = expr_graph.reify()

      # PyMC3 needs names for each RV
      opt_graph_tt.owner.inputs[1].name = 'Y_new'

      return opt_graph_tt


  fgraph_reparam = reparam_graph(fgraph.outputs[0])

  # Convert the symbolic-pymc graph into a PyMC3 graph so that we can sample it
  model_recentered = graph_model(fgraph_reparam)

  np.random.seed(123)

  with model_centered:
      centered_trace = pm.sample(draws=5000, tune=1000, cores=4)[1000:]

  with model_recentered:
      recentered_trace = pm.sample(draws=5000, tune=1000, cores=4)[1000:]

  # @pm.model
  # def model_centered():
  #     mu_a = yield dist.Normal('mu_a', mu=0., sigma=100**2)
  #     sigma_a = yield tfp.distributions.half_cauchy\
  #                                      .HalfCauchy(loc=0, scale=100**2)\
  #                                      .log_prob(5)
  #     mu_b = yield dist.Normal('mu_b', mu=0., sigma=100**2)
  #     sigma_b = yield tfp.distributions.half_cauchy\
  #                                      .HalfCauchy(loc=0, scale=100**2)\
  #                                      .log_prob(5)
  #     a = yield dist.Normal('a', mu=mu_a, sd=sigma_a, shape=n_counties)
  #     b = yield dist.Normal('b', mu=mu_b, sd=sigma_b, shape=n_counties)
  #     eps = yield tfp.distributions.half_cauchy\
  #                                  .HalfCauchy(loc=0, scale=100**2)\
  #                                  .log_prob(5)
  #     radon_est = a[county_idx] + b[county_idx] * data.floor.values
  #     radon_like = yield dist.Normal('radon_like', mu=radon_est, sd=eps,
  #                                    observed=data.log_radon)
  #     return radon_like
#+END_SRC


